import { useState as f, useCallback as G } from "react";
var g = {};
Object.defineProperty(g, "__esModule", { value: !0 });
var m = g.PowerGlitch = void 0;
const y = (t = "always") => ({
  playMode: t,
  createContainers: !0,
  hideOverflow: !1,
  timing: t === "always" ? { duration: 2 * 1e3, iterations: 1 / 0 } : { duration: 250, iterations: 1 },
  glitchTimeSpan: t === "always" ? { start: 0.5, end: 0.7 } : { start: 0, end: 1 },
  shake: {
    velocity: 15,
    amplitudeX: 0.2,
    amplitudeY: 0.2
  },
  slice: t === "click" ? {
    count: 15,
    velocity: 20,
    minHeight: 0.02,
    maxHeight: 0.15,
    hueRotate: !0
  } : {
    count: 6,
    velocity: 15,
    minHeight: 0.02,
    maxHeight: 0.15,
    hueRotate: !0
  }
}), p = (t, i) => {
  if (!t.glitchTimeSpan)
    return 1;
  const e = t.glitchTimeSpan.start, n = t.glitchTimeSpan.end;
  if (i < e || i > n)
    return 0;
  const r = e + (n - e) / 2;
  return i < r ? (i - e) / (r - e) : (n - i) / (n - r);
}, u = (t, i) => (Math.random() - 0.5) * 2 * p(t, i), $ = ({ minHeight: t, maxHeight: i, minWidth: e, maxWidth: n }) => {
  const r = Math.floor(Math.random() * ((i - t) * 100 + 1)) + t * 100, c = Math.floor(Math.random() * ((n - e) * 100 + 1)) + e * 100, a = Math.floor(Math.random() * (100 - r)), s = Math.floor(Math.random() * (100 - c)), l = `${s + c}% ${a}%`, o = `${s + c}% ${a + r}%`, h = `${s}% ${a + r}%`, d = `${s}% ${a}%`;
  return `polygon(${l},${o},${h},${d})`;
}, C = (t) => {
  const i = Math.floor(t.slice.velocity * t.timing.duration / 1e3) + 1, e = [];
  for (let n = 0; n < i; ++n) {
    if (p(t, n / i) === 0) {
      e.push({
        opacity: "0",
        transform: "",
        clipPath: "unset"
      });
      continue;
    }
    const r = u(t, n / i) * 30, c = {
      opacity: "1",
      transform: `translate3d(${r}%,0,0)`,
      clipPath: $({ minHeight: t.slice.minHeight, maxHeight: t.slice.maxHeight, minWidth: 1, maxWidth: 1 })
    };
    t.slice.hueRotate && (c.filter = `hue-rotate(${Math.floor(u(t, n / i) * 360)}deg)`), e.push(c);
  }
  return {
    steps: e,
    timing: Object.assign({ easing: `steps(${i},jump-start)` }, t.timing)
  };
}, w = (t) => {
  if (!t.shake)
    return {
      steps: [],
      timing: {}
    };
  const i = Math.floor(t.shake.velocity * t.timing.duration / 1e3) + 1, e = [];
  for (let n = 0; n < i; ++n) {
    const r = u(t, n / i) * t.shake.amplitudeX * 100, c = u(t, n / i) * t.shake.amplitudeY * 100;
    e.push({
      transform: `translate3d(${r}%,${c}%,0)`
    });
  }
  return {
    steps: e,
    timing: Object.assign({ easing: `steps(${i},jump-start)` }, t.timing)
  };
}, v = (t) => [
  w(t),
  ...Array.from({ length: t.slice.count }).map(() => C(t))
], E = (...t) => {
  const i = (e) => e && typeof e == "object";
  return t.reduce((e, n) => (Object.keys(n).forEach((r) => {
    const c = e[r], a = n[r];
    if (Array.isArray(c) && Array.isArray(a)) {
      e[r] = c.concat(...a);
      return;
    }
    if (i(c) && i(a)) {
      e[r] = E(c, a);
      return;
    }
    a !== void 0 && (e[r] = a);
  }), e), {});
}, A = (t, i) => {
  var e, n;
  if (!i.createContainers)
    return {
      container: t,
      layersContainer: t,
      glitched: t.firstElementChild
    };
  if (!t.dataset.glitched) {
    const a = document.createElement("div"), s = document.createElement("div");
    return getComputedStyle(t).getPropertyValue("display").match(/^inline/) && (s.style.display = "inline-block"), s.appendChild(a), (e = t.parentElement) === null || e === void 0 || e.insertBefore(s, t), a.prepend(t), {
      container: s,
      layersContainer: a,
      glitched: t
    };
  }
  const r = t.parentElement, c = (n = t.parentElement) === null || n === void 0 ? void 0 : n.parentElement;
  for (; r.children.length > 1; )
    r.removeChild(r.children[1]);
  return r.firstElementChild.getAnimations().forEach((a) => a.cancel()), {
    container: c,
    layersContainer: r,
    glitched: t
  };
}, M = (t, i, e) => {
  const { glitched: n, container: r, layersContainer: c } = A(t, e);
  c.style.display = "grid", e.hideOverflow && (r.style.overflow = "hidden"), e.html && (n.innerHTML = e.html), n.style.gridArea = "1/1/-1/-1";
  const a = n.cloneNode(!0);
  a.style.gridArea = "1/1/-1/-1", a.style.userSelect = "none", a.style.pointerEvents = "none", a.style.opacity = "0";
  for (let o = 0; o < i.length - 1; ++o) {
    const h = a.cloneNode(!0);
    c.appendChild(h);
  }
  const s = () => {
    i.forEach((o, h) => {
      c.children[h].animate(o.steps, o.timing);
    });
  }, l = () => {
    i.forEach((o, h) => {
      c.children[h].getAnimations().forEach((d) => {
        d.cancel();
      });
    });
  };
  switch (r.onmouseenter = null, r.onmouseleave = null, r.onclick = null, e.playMode) {
    case "always":
      s();
      break;
    case "hover":
      r.onmouseenter = s, r.onmouseleave = l;
      break;
    case "click":
      r.onclick = () => {
        l(), s();
      };
      break;
  }
  return t.dataset.glitched = "1", { container: r, startGlitch: s, stopGlitch: l };
}, b = (t = ".powerglitch", i = {}) => {
  const e = E(y(i.playMode), i);
  let n = [];
  typeof t == "string" ? n = Array.from(document.querySelectorAll(t)) : t instanceof NodeList ? n = Array.from(t) : Array.isArray(t) ? n = t : t instanceof HTMLElement && (n = [t]);
  const r = v(e), c = n.map((a) => M(a, r, e));
  return {
    containers: c.map((a) => a.container),
    startGlitch: () => c.forEach((a) => a.startGlitch()),
    stopGlitch: () => c.forEach((a) => a.stopGlitch())
  };
};
m = g.PowerGlitch = {
  glitch: b,
  generateLayers: v,
  getDefaultOptions: y
};
function H(t) {
  const [i, e] = f(t), [n, r] = f(() => () => {
  }), [c, a] = f(() => () => {
  });
  return {
    ref: G((l) => {
      if (!l)
        return;
      const o = m.glitch(l, i);
      r(() => o.startGlitch), a(() => o.stopGlitch);
    }, [i]),
    startGlitch: n,
    stopGlitch: c,
    setOptions: e
  };
}
export {
  H as useGlitch
};
